CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
22,"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",Base,Stable,"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.","Many file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the product may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.",::NATURE:ChildOf:CWE ID:706:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:706:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:668:VIEW ID:1000::,"::ORDINALITY:Primary::ORDINALITY:Resultant::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Directory traversal::TERM:Path traversal:DESCRIPTION:Path traversal is preferred over directory traversal, but both terms are attack-focused.::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:The attacker may be able to create or overwrite critical files that are used to execute code, such as programs or libraries.::SCOPE:Integrity:IMPACT:Modify Files or Directories:NOTE:The attacker may be able to overwrite or create critical files, such as programs, libraries, or important data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, appending a new account at the end of a password file may allow an attacker to bypass authentication.::SCOPE:Confidentiality:IMPACT:Read Files or Directories:NOTE:The attacker may be able read the contents of unexpected files and expose sensitive data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, by reading a password file, the attacker could conduct brute force password guessing attacks in order to break into an account on the system.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:The attacker may be able to overwrite, delete, or corrupt unexpected critical files such as programs, libraries, or important data. This may prevent the product from working at all and in the case of a protection mechanisms such as authentication, it has the potential to lockout every user of the product.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated techniques can find areas where path traversal weaknesses exist. However, tuning or customization may be required to remove or de-prioritize path-traversal problems that are only exploitable by the product's administrator - or other privileged users - and thus potentially valid behavior or, at worst, a bug instead of a vulnerability.:EFFECTIVENESS:High::METHOD:Manual Static Analysis:DESCRIPTION:Manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all file access operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in Perl realpath() in PHP::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::","::REFERENCE:CVE-2022-45918:DESCRIPTION:Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using ../ sequences (CWE-24):LINK:https://www.cve.org/CVERecord?id=CVE-2022-45918::REFERENCE:CVE-2019-20916:DESCRIPTION:Python package manager does not correctly restrict the filename specified in a Content-Disposition header, allowing arbitrary file read using path traversal sequences such as ../:LINK:https://www.cve.org/CVERecord?id=CVE-2019-20916::REFERENCE:CVE-2022-31503:DESCRIPTION:Python package constructs filenames using an unsafe os.path.join call on untrusted input, allowing absolute path traversal because os.path.join resets the pathname to an absolute path that is specified as part of the input.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-31503::REFERENCE:CVE-2022-24877:DESCRIPTION:directory traversal in Go-based Kubernetes operator app allows accessing data from the controller's pod file system via ../ sequences in a yaml file:LINK:https://www.cve.org/CVERecord?id=CVE-2022-24877::REFERENCE:CVE-2021-21972:DESCRIPTION:Chain: Cloud computing virtualization platform does not require authentication for upload of a tar format file (CWE-306), then uses .. path traversal sequences (CWE-23) in the file to access unexpected files, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-21972::REFERENCE:CVE-2020-4053:DESCRIPTION:a Kubernetes package manager written in Go allows malicious plugins to inject path traversal sequences into a plugin archive (Zip slip) to copy a file outside the intended directory:LINK:https://www.cve.org/CVERecord?id=CVE-2020-4053::REFERENCE:CVE-2020-3452:DESCRIPTION:Chain: security product has improper input validation (CWE-20) leading to directory traversal (CWE-22), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-3452::REFERENCE:CVE-2019-10743:DESCRIPTION:Go-based archive library allows extraction of files to locations outside of the target folder with ../ path traversal sequences in filenames in a zip file, aka Zip Slip:LINK:https://www.cve.org/CVERecord?id=CVE-2019-10743::REFERENCE:CVE-2010-0467:DESCRIPTION:Newsletter module allows reading arbitrary files using ../ sequences.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0467::REFERENCE:CVE-2006-7079:DESCRIPTION:Chain: PHP app uses extract for register_globals compatibility layer (CWE-621), enabling path traversal (CWE-22):LINK:https://www.cve.org/CVERecord?id=CVE-2006-7079::REFERENCE:CVE-2009-4194:DESCRIPTION:FTP server allows deletion of arbitrary files using .. in the DELE command.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4194::REFERENCE:CVE-2009-4053:DESCRIPTION:FTP server allows creation of arbitrary directories using .. in the MKD command.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4053::REFERENCE:CVE-2009-0244:DESCRIPTION:FTP service for a Bluetooth device allows listing of directories, and creation or reading of files using .. sequences.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0244::REFERENCE:CVE-2009-4013:DESCRIPTION:Software package maintenance program allows overwriting arbitrary files using ../ sequences.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4013::REFERENCE:CVE-2009-4449:DESCRIPTION:Bulletin board allows attackers to determine the existence of files using the avatar.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4449::REFERENCE:CVE-2009-4581:DESCRIPTION:PHP program allows arbitrary code execution using .. in filenames that are fed to the include() function.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4581::REFERENCE:CVE-2010-0012:DESCRIPTION:Overwrite of files using a .. in a Torrent file.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0012::REFERENCE:CVE-2010-0013:DESCRIPTION:Chat program allows overwriting files using a custom smiley request.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0013::REFERENCE:CVE-2008-5748:DESCRIPTION:Chain: external control of values for user's desired language and theme enables path traversal.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5748::REFERENCE:CVE-2009-1936:DESCRIPTION:Chain: library file sends a redirect if it is directly requested but continues to execute, allowing remote file inclusion and path traversal.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1936::",::File Processing::,::File or Directory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Path Traversal::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A4:ENTRY NAME:Insecure Direct Object Reference:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A2:ENTRY NAME:Broken Access Control:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO02-C:ENTRY NAME:Canonicalize path names originating from untrusted sources::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS00-PL:ENTRY NAME:Canonicalize path names before validating them:MAPPING FIT:Exact::TAXONOMY NAME:WASC:ENTRY ID:33:ENTRY NAME:Path Traversal::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP16:ENTRY NAME:Path Traversal::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-22::",::126::64::76::78::79::,"::TYPE:Relationship:NOTE:Pathname equivalence can be regarded as a type of canonicalization error.::TYPE:Relationship:NOTE:Some pathname equivalence issues are not directly related to directory traversal, rather are used to bypass security-relevant checks for whether a file/directory can be accessed by the attacker (e.g. a trailing / on a filename could bypass access rules that don't expect a trailing /, causing a server to provide the file when it normally would not).::TYPE:Terminology:NOTE:Like other weaknesses, terminology is often based on the types of manipulations used, instead of the underlying weaknesses. Some people use directory traversal only to refer to the injection of .. and equivalent sequences whose specific meaning is to traverse directories. Other variants like absolute pathname and drive letter have the *effect* of directory traversal, but some people may not call it such, since it doesn't involve .. or equivalent.::TYPE:Research Gap:NOTE:Many variants of path traversal attacks are probably under-studied with respect to root cause. CWE-790 and CWE-182 begin to cover part of this gap.::TYPE:Research Gap:NOTE:Incomplete diagnosis or reporting of vulnerabilities can make it difficult to know which variant is affected. For example, a researcher might say that .. is vulnerable, but not test ../ which may also be vulnerable. Any combination of directory separators (/, , etc.) and numbers of . (e.g. ....) can produce unique variants; for example, the //../ variant is not listed (CVE-2004-0325). See this entry's children and lower-level descendants.::",
78,"Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",Base,Stable,"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.","This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage. There are at least two subtypes of OS command injection: The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(nslookup [HOSTNAME]) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing. The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use exec([COMMAND]) to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line. From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.",::NATURE:ChildOf:CWE ID:77:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:77:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:77:VIEW ID:1340:ORDINAL:Primary::NATURE:CanAlsoBe:CWE ID:88:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Shell injection::TERM:Shell metacharacters::","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Non-Repudiation:IMPACT:Execute Unauthorized Code or Commands:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Read Files or Directories:IMPACT:Modify Files or Directories:IMPACT:Read Application Data:IMPACT:Modify Application Data:IMPACT:Hide Activities:NOTE:Attackers could execute unauthorized commands, which could then be used to disable the product, or read and modify data for which the attacker does not have permissions to access directly. Since the targeted application is directly executing the commands instead of the attacker, any malicious activities may appear to come from the application or the application's owner.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke OS commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:If at all possible, use library calls rather than external processes to recreate the desired functionality.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:DESCRIPTION:For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).::PHASE:Implementation:DESCRIPTION:If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.::PHASE:Architecture and Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ; and > characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Operation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.::PHASE:Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::","::REFERENCE:CVE-2020-10987:DESCRIPTION:OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-10987::REFERENCE:CVE-2020-10221:DESCRIPTION:Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-10221::REFERENCE:CVE-2020-9054:DESCRIPTION:Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-9054::REFERENCE:CVE-1999-0067:DESCRIPTION:Canonical example of OS command injection. CGI program does not neutralize | metacharacter when invoking a phonebook program.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0067::REFERENCE:CVE-2001-1246:DESCRIPTION:Language interpreter's mail function accepts another argument that is concatenated to a string used in a dangerous popen() call. Since there is no neutralization of this argument, both OS Command Injection (CWE-78) and Argument Injection (CWE-88) are possible.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1246::REFERENCE:CVE-2002-0061:DESCRIPTION:Web server allows command execution using | (pipe) character.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0061::REFERENCE:CVE-2003-0041:DESCRIPTION:FTP client does not filter | from filenames returned by the server, allowing for OS command injection.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0041::REFERENCE:CVE-2008-2575:DESCRIPTION:Shell metacharacters in a filename in a ZIP archive:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2575::REFERENCE:CVE-2002-1898:DESCRIPTION:Shell metacharacters in a telnet:// link are not properly handled when the launching application processes the link.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1898::REFERENCE:CVE-2008-4304:DESCRIPTION:OS command injection through environment variable.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4304::REFERENCE:CVE-2008-4796:DESCRIPTION:OS command injection through https:// URLs:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4796::REFERENCE:CVE-2007-3572:DESCRIPTION:Chain: incomplete denylist for OS command injection:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3572::REFERENCE:CVE-2012-1988:DESCRIPTION:Product allows remote users to execute arbitrary commands by creating a file whose pathname contains shell metacharacters.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-1988::",::Program Invocation::,::System Process::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:OS Command Injection::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A3:ENTRY NAME:Malicious File Execution:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ENV03-C:ENTRY NAME:Sanitize the environment when invoking external programs::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ENV33-C:ENTRY NAME:Do not call system():MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR02-C:ENTRY NAME:Sanitize data passed to complex subsystems::TAXONOMY NAME:WASC:ENTRY ID:31:ENTRY NAME:OS Commanding::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS07-J:ENTRY NAME:Do not pass untrusted, unsanitized data to the Runtime.exec() method::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-78::",::108::15::43::6::88::,"::TYPE:Terminology:NOTE:The OS command injection phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an -exec switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX find command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.::TYPE:Research Gap:NOTE:More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.::",
79,"Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",Base,Stable,"The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.","Cross-site scripting (XSS) vulnerabilities occur when: Untrusted data enters a web application, typically from a web request. The web application dynamically generates a web page that contains this untrusted data. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain. There are three main kinds of XSS: Type 1: Reflected XSS (or Non-Persistent) - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser. Type 2: Stored XSS (or Persistent) - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. Type 0: DOM-Based XSS - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as drive-by hacking. In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:494:VIEW ID:1000::NATURE:PeerOf:CWE ID:352:VIEW ID:1000::,"::ORDINALITY:Resultant::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Web Based:TECHNOLOGY PREVALENCE:Often::,"::The Same Origin Policy states that browsers should limit the resources accessible to scripts running on a given web site, or origin, to the resources associated with that web site on the client-side, and not the client-side resources of any other sites or origins. The goal is to prevent one site from being able to modify or read the contents of an unrelated site. Since the World Wide Web involves interactions between many sites, this policy is important for browsers to enforce. When referring to XSS, the Domain of a website is roughly equivalent to the resources associated with that website on the client-side of the connection. That is, the domain can be thought of as all resources the browser is storing for the user's interactions with this particular site.::","::TERM:XSS:DESCRIPTION:A common abbreviation for Cross-Site Scripting.::TERM:HTML Injection:DESCRIPTION:Used as a synonym of stored (Type 2) XSS.::TERM:CSS:DESCRIPTION:In the early years after initial discovery of XSS, CSS was a commonly-used acronym. However, this would cause confusion with Cascading Style Sheets, so usage of this acronym has declined significantly.::","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Access Control:SCOPE:Confidentiality:IMPACT:Bypass Protection Mechanism:IMPACT:Read Application Data:NOTE:The most common attack performed with cross-site scripting involves the disclosure of information stored in user cookies. Typically, a malicious user will craft a client-side script, which -- when parsed by a web browser -- performs some activity (such as sending all site cookies to a given E-mail address). This script will be loaded and run by each user visiting the web site. Since the site requesting to run the script has access to the cookies in question, the malicious script does also.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:In some circumstances it may be possible to run arbitrary code on a victim's computer when cross-site scripting is combined with other flaws.::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:IMPACT:Read Application Data:NOTE:The consequence of an XSS attack is the same regardless of whether it is stored or reflected. The difference is in how the payload arrives at the server. XSS can cause a variety of problems for the end user that range in severity from an annoyance to complete account compromise. Some cross-site scripting vulnerabilities can be exploited to manipulate or steal cookies, create requests that can be mistaken for those of a valid user, compromise confidential information, or execute malicious code on the end user systems for a variety of nefarious purposes. Other damaging attacks include the disclosure of end user files, installation of Trojan horse programs, redirecting the user to some other page or site, running Active X controls (under Microsoft Internet Explorer) from sites that a user perceives as trustworthy, and modifying presentation of content.::","::METHOD:Automated Static Analysis:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible, especially when multiple components are involved.:EFFECTIVENESS:Moderate::METHOD:Black Box:DESCRIPTION:Use the XSS Cheat Sheet [REF-714] or automated test-generation tools to help launch a wide variety of attacks against your web application. The Cheat Sheet contains many subtle XSS variations that are specifically targeted against weak XSS defenses.:EFFECTIVENESS:Moderate::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.::PHASE:Implementation Architecture and Design:DESCRIPTION:Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Parts of the same output document may require different encodings, which will vary depending on whether the output is in the: HTML body Element attributes (such as src=XYZ) URIs JavaScript sections Cascading Style Sheets and style property etc. Note that HTML Entity Encoding is only appropriate for the HTML body. Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.:EFFECTIVENESS:Limited::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.::PHASE:Implementation:DESCRIPTION:With Struts, write all data from form beans with the bean's filter attribute set to true.::PHASE:Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (<3) would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the < character, which would need to be escaped or otherwise handled. In this case, stripping the < might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address. Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::","::REFERENCE:CVE-2021-25926:DESCRIPTION:Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-25926::REFERENCE:CVE-2021-25963:DESCRIPTION:Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-25963::REFERENCE:CVE-2021-1879:DESCRIPTION:Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-1879::REFERENCE:CVE-2020-3580:DESCRIPTION:Chain: improper input validation (CWE-20) in firewall product leads to XSS (CWE-79), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-3580::REFERENCE:CVE-2014-8958:DESCRIPTION:Admin GUI allows XSS through cookie.:LINK:https://www.cve.org/CVERecord?id=CVE-2014-8958::REFERENCE:CVE-2017-9764:DESCRIPTION:Web stats program allows XSS through crafted HTTP header.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-9764::REFERENCE:CVE-2014-5198:DESCRIPTION:Web log analysis product allows XSS through crafted HTTP Referer header.:LINK:https://www.cve.org/CVERecord?id=CVE-2014-5198::REFERENCE:CVE-2008-5080:DESCRIPTION:Chain: protection mechanism failure allows XSS:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5080::REFERENCE:CVE-2006-4308:DESCRIPTION:Chain: incomplete denylist (CWE-184) only checks javascript: tag, allowing XSS (CWE-79) using other tags:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4308::REFERENCE:CVE-2007-5727:DESCRIPTION:Chain: incomplete denylist (CWE-184) only removes SCRIPT tags, enabling XSS (CWE-79):LINK:https://www.cve.org/CVERecord?id=CVE-2007-5727::REFERENCE:CVE-2008-5770:DESCRIPTION:Reflected XSS using the PATH_INFO in a URL:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5770::REFERENCE:CVE-2008-4730:DESCRIPTION:Reflected XSS not properly handled when generating an error message:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4730::REFERENCE:CVE-2008-5734:DESCRIPTION:Reflected XSS sent through email message.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5734::REFERENCE:CVE-2008-0971:DESCRIPTION:Stored XSS in a security product.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0971::REFERENCE:CVE-2008-5249:DESCRIPTION:Stored XSS using a wiki page.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5249::REFERENCE:CVE-2006-3568:DESCRIPTION:Stored XSS in a guestbook application.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-3568::REFERENCE:CVE-2006-3211:DESCRIPTION:Stored XSS in a guestbook application using a javascript: URI in a bbcode img tag.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-3211::REFERENCE:CVE-2006-3295:DESCRIPTION:Chain: library file is not protected against a direct request (CWE-425), leading to reflected XSS (CWE-79).:LINK:https://www.cve.org/CVERecord?id=CVE-2006-3295::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Cross-site scripting (XSS)::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Cross-site Scripting::TAXONOMY NAME:CLASP:ENTRY NAME:Cross-site scripting::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A1:ENTRY NAME:Cross Site Scripting (XSS):MAPPING FIT:Exact::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A4:ENTRY NAME:Cross-Site Scripting (XSS) Flaws:MAPPING FIT:Exact::TAXONOMY NAME:WASC:ENTRY ID:8:ENTRY NAME:Cross-site Scripting::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-79::",::209::588::591::592::63::85::,"::TYPE:Relationship:NOTE:There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.::TYPE:Applicable Platform:NOTE:XSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.::",
89,"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",Base,Stable,"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.","Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or product package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:This weakness typically appears in data-rich applications that save user inputs in a database.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::","::REFERENCE:CVE-2023-32530:DESCRIPTION:SQL injection in security product dashboard using crafted certificate fields:LINK:https://www.cve.org/CVERecord?id=CVE-2023-32530::REFERENCE:CVE-2021-42258:DESCRIPTION:SQL injection in time and billing software, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-42258::REFERENCE:CVE-2021-27101:DESCRIPTION:SQL injection in file-transfer system via a crafted Host header, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-27101::REFERENCE:CVE-2020-12271:DESCRIPTION:SQL injection in firewall product's admin interface or user portal, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-12271::REFERENCE:CVE-2019-3792:DESCRIPTION:An automation system written in Go contains an API that is vulnerable to SQL injection allowing the attacker to read privileged data.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-3792::REFERENCE:CVE-2004-0366:DESCRIPTION:chain: SQL injection in library intended for database authentication allows SQL injection and authentication bypass.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0366::REFERENCE:CVE-2008-2790:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2790::REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2223::REFERENCE:CVE-2007-6602:DESCRIPTION:SQL injection via user name.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6602::REFERENCE:CVE-2008-5817:DESCRIPTION:SQL injection via user name or password fields.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5817::REFERENCE:CVE-2003-0377:DESCRIPTION:SQL injection in security product, using a crafted group name.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0377::REFERENCE:CVE-2008-2380:DESCRIPTION:SQL injection in authentication library.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2380::REFERENCE:CVE-2017-11508:DESCRIPTION:SQL injection in vulnerability management and reporting tool, using a crafted password.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-11508::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:SQL injection::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:SQL Injection::TAXONOMY NAME:CLASP:ENTRY NAME:SQL injection::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:19:ENTRY NAME:SQL Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-89::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:IDS00-J:ENTRY NAME:Prevent SQL injection:MAPPING FIT:Exact::",::108::109::110::470::66::7::,"::TYPE:Relationship:NOTE:SQL injection can be resultant from special character mismanagement, MAID, or denylist/allowlist problems. It can be primary to authentication errors.::",
99,"Improper Control of Resource Identifiers ('Resource Injection')",Class,Draft,"The product receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.","A resource injection issue occurs when the following two conditions are met: An attacker can specify the identifier used to access a system resource. For example, an attacker might be able to specify part of the name of a file to be opened or a port number to be used. By specifying the resource, the attacker gains a capability that would not otherwise be permitted. For example, the program may give the attacker the ability to overwrite the specified file, run with a configuration controlled by the attacker, or transmit sensitive information to a third-party server. This may enable an attacker to access or modify otherwise protected system resources.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:706:VIEW ID:1000::NATURE:CanAlsoBe:CWE ID:73:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Insecure Direct Object Reference:DESCRIPTION:OWASP uses this term, although it is effectively the same as resource injection.::","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data:IMPACT:Read Files or Directories:IMPACT:Modify Files or Directories:NOTE:An attacker could gain access to or modify sensitive data or system resources. This could allow access to protected files or directories including configuration files and files containing sensitive information.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, it can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::","::REFERENCE:CVE-2013-4787:DESCRIPTION:chain: mobile OS verifies cryptographic signature of file in an archive, but then installs a different file with the same name that is also listed in the archive.:LINK:https://www.cve.org/CVERecord?id=CVE-2013-4787::",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Resource Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-99::",::10::240::75::,"::TYPE:Relationship:NOTE:Resource injection that involves resources stored on the filesystem goes by the name path manipulation (CWE-73).::TYPE:Maintenance:NOTE:The relationship between CWE-99 and CWE-610 needs further investigation and clarification. They might be duplicates. CWE-99 Resource Injection, as originally defined in Seven Pernicious Kingdoms taxonomy, emphasizes the identifier used to access a system resource such as a file name or port number, yet it explicitly states that the resource injection term does not apply to path manipulation, which effectively identifies the path at which a resource can be found and could be considered to be one aspect of a resource identifier. Also, CWE-610 effectively covers any type of resource, whether that resource is at the system layer, the application layer, or the code layer.::",
120,"Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",Base,Incomplete,"The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.","A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the classic case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Resultant::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Classic Buffer Overflow:DESCRIPTION:This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.::TERM:Unbounded Transfer::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of the product's implicit security policy. This can often be used to subvert any other security service.::SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the product into an infinite loop.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Operation Build and Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation Build and Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].:EFFECTIVENESS:Defense in Depth::PHASE:Build and Compilation Operation:DESCRIPTION:Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2000-1094:DESCRIPTION:buffer overflow using command with long argument:LINK:https://www.cve.org/CVERecord?id=CVE-2000-1094::REFERENCE:CVE-1999-0046:DESCRIPTION:buffer overflow in local program using long environment variable:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0046::REFERENCE:CVE-2002-1337:DESCRIPTION:buffer overflow in comment characters, when product increments a counter for a > but does not decrement for <:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1337::REFERENCE:CVE-2003-0595:DESCRIPTION:By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0595::REFERENCE:CVE-2001-0191:DESCRIPTION:By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0191::",::Memory Management::,::Memory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Unbounded Transfer ('classic overflow')::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Buffer Overflow::TAXONOMY NAME:CLASP:ENTRY NAME:Buffer overflow::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A5:ENTRY NAME:Buffer Overflows:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:Exact::TAXONOMY NAME:WASC:ENTRY ID:7:ENTRY NAME:Buffer Overflow::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-120::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-120::",::10::100::14::24::42::44::45::46::47::67::8::9::92::,"::TYPE:Relationship:NOTE:At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.::TYPE:Terminology:NOTE:Many issues that are now called buffer overflows are substantively different than the classic overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.::",
129,"Improper Validation of Array Index",Variant,Draft,"The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.","",::NATURE:ChildOf:CWE ID:1285:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::NATURE:CanPrecede:CWE ID:823:VIEW ID:1000::NATURE:CanPrecede:CWE ID:789:VIEW ID:1000::,"::ORDINALITY:Resultant:DESCRIPTION:The most common condition situation leading to an out-of-bounds array index is the use of loop index variables as buffer indexes. If the end condition for the loop is subject to a flaw, the index can grow or shrink unbounded, therefore causing a buffer overflow or underflow. Another common situation leading to this condition is the use of a function's return value, or the resulting value of a calculation directly as an index in to a buffer.::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:out-of-bounds array index::TERM:index-out-of-range::TERM:array index underflow::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Use of an index that is outside the bounds of an array will very likely result in the corruption of relevant memory and perhaps instructions, leading to a crash, if the values are outside of the valid memory area.::SCOPE:Integrity:IMPACT:Modify Memory:NOTE:If the memory corrupted is data, rather than instructions, the system will continue to function with improper values.::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Read Memory:NOTE:Use of an index that is outside the bounds of an array can also trigger out-of-bounds read or write operations, or operations on the wrong objects; i.e., buffer overflows are not always the result. This may result in the exposure or modification of sensitive data.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow and possibly without the use of large inputs if a precise index can be controlled.::SCOPE:Integrity:SCOPE:Availability:SCOPE:Confidentiality:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Read Memory:IMPACT:Modify Memory:NOTE:A single fault could allow either an overflow (CWE-788) or underflow (CWE-786) of the array index. What happens next will depend on the type of operation being performed out of bounds, but can expose sensitive information, cause a system crash, or possibly lead to arbitrary code execution.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report array index errors that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Black Box:DESCRIPTION:Black box methods might not get the needed code coverage within limited time constraints, and a dynamic test might not produce any noticeable side effects even if it is successful.::","::PHASE:Architecture and Design:STRATEGY:Input Validation:DESCRIPTION:Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.::PHASE:Operation Build and Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.::PHASE:Implementation:DESCRIPTION:Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2005-0369:DESCRIPTION:large ID in packet used as array index:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0369::REFERENCE:CVE-2001-1009:DESCRIPTION:negative array index as argument to POP LIST command:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1009::REFERENCE:CVE-2003-0721:DESCRIPTION:Integer signedness error leads to negative array index:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0721::REFERENCE:CVE-2004-1189:DESCRIPTION:product does not properly track a count and a maximum number, which can lead to resultant array index overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1189::REFERENCE:CVE-2007-5756:DESCRIPTION:Chain: device driver for packet-capturing software allows access to an unintended IOCTL with resultant array index error.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5756::REFERENCE:CVE-2005-2456:DESCRIPTION:Chain: array index error (CWE-129) leads to deadlock (CWE-833):LINK:https://www.cve.org/CVERecord?id=CVE-2005-2456::",,::Memory::,"::TAXONOMY NAME:CLASP:ENTRY NAME:Unchecked array indexing::TAXONOMY NAME:PLOVER:ENTRY NAME:INDEX - Array index overflow::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR00-C:ENTRY NAME:Understand how arrays work::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Do not add or subtract an integer to a pointer if the resulting value does not refer to a valid array element::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT32-C:ENTRY NAME:Ensure that operations on signed integers do not result in overflow::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS32-PL:ENTRY NAME:Validate any integer that is used as an array index:MAPPING FIT:Imprecise::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-129::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",::100::,"::TYPE:Relationship:NOTE:This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript.::TYPE:Theoretical:NOTE:An improperly validated array index might lead directly to the always-incorrect behavior of access of array using out-of-bounds index.::",
134,"Use of Externally-Controlled Format String",Base,Draft,"The product uses a function that accepts a format string as an argument, but the format string originates from an external source.","When an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems. It should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.",::NATURE:ChildOf:CWE ID:668:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:668:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:Perl:LANGUAGE PREVALENCE:Rarely::,"","","::PHASE:Implementation:NOTE:The programmer rarely intends for a format string to be externally-controlled at all. This weakness is frequently introduced in code that constructs log messages, where a constant format string is omitted.::PHASE:Implementation:NOTE:In cases such as localization and internationalization, the language-specific message repositories could be an avenue for exploitation, but the format string issue would be resultant, since attacker control of those repositories would also allow modification of message length, format, and content.::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:Format string problems allow for information disclosure which can severely simplify exploitation of the program.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:Format string problems can result in the execution of arbitrary code.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.::METHOD:Black Box:DESCRIPTION:Since format strings often occur in rarely-occurring erroneous conditions (e.g. for error message logging), they can be difficult to detect using black box methods. It is highly likely that many latent issues exist in executables that do not have associated source code (or equivalent source.:EFFECTIVENESS:Limited::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary / Bytecode simple extractor - strings, ELF readers, etc.:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Warning Flags:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Requirements:DESCRIPTION:Choose a language that is not subject to this flaw.::PHASE:Implementation:DESCRIPTION:Ensure that all format string functions are passed a static string which cannot be controlled by the user, and that the proper number of arguments are always sent to that function as well. If at all possible, use functions that do not support the %n operator in format strings. [REF-116] [REF-117]::PHASE:Build and Compilation:DESCRIPTION:Run compilers and linkers with high warning levels, since they may detect incorrect usage.::","::REFERENCE:CVE-2002-1825:DESCRIPTION:format string in Perl program:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1825::REFERENCE:CVE-2001-0717:DESCRIPTION:format string in bad call to syslog function:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0717::REFERENCE:CVE-2002-0573:DESCRIPTION:format string in bad call to syslog function:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0573::REFERENCE:CVE-2002-1788:DESCRIPTION:format strings in NNTP server responses:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1788::REFERENCE:CVE-2006-2480:DESCRIPTION:Format string vulnerability exploited by triggering errors or warnings, as demonstrated via format string specifiers in a .bmp filename.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2480::REFERENCE:CVE-2007-2027:DESCRIPTION:Chain: untrusted search path enabling resultant format string by loading malicious internationalization messages:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2027::",::Logging::Error Handling::String Processing::,::Memory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Format string vulnerability::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Format String::TAXONOMY NAME:CLASP:ENTRY NAME:Format string problem::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO30-C:ENTRY NAME:Exclude user input from format strings:MAPPING FIT:Exact::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO47-C:ENTRY NAME:Use valid format strings:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:6:ENTRY NAME:Format String::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS06-J:ENTRY NAME:Exclude user input from format strings::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS30-PL:ENTRY NAME:Exclude user input from format strings:MAPPING FIT:Exact::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-134::",::135::67::,"::TYPE:Applicable Platform:NOTE:This weakness is possible in any programming language that support format strings.::TYPE:Other:NOTE:While Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program. Frequently targeted entities are file names, process names, identifiers. Format string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.::TYPE:Research Gap:NOTE:Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.::",
252,"Unchecked Return Value",Base,Draft,"The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.","Two common programmer assumptions are this function call can never fail and it doesn't matter if this function call fails. If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.",::NATURE:ChildOf:CWE ID:754:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:754:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:476:VIEW ID:1000:CHAIN ID:690::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"::Many functions will return some value about the success of their actions. This will alert the program whether or not to handle any errors caused by that function.::","","::PHASE:Implementation::","",,"::SCOPE:Availability:SCOPE:Integrity:IMPACT:Unexpected State:IMPACT:DoS: Crash, Exit, or Restart:NOTE:An unexpected return value could place the system in a state that could lead to a crash or other unintended behaviors.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Check the results of all functions that return a value and verify that the value is expected.:EFFECTIVENESS:High::PHASE:Implementation:DESCRIPTION:Ensure that you account for all possible return values from the function.::PHASE:Implementation:DESCRIPTION:When designing a function, make sure you return a value or throw an exception in case of an error.::","::REFERENCE:CVE-2020-17533:DESCRIPTION:Chain: unchecked return value (CWE-252) of some functions for policy enforcement leads to authorization bypass (CWE-862):LINK:https://www.cve.org/CVERecord?id=CVE-2020-17533::REFERENCE:CVE-2020-6078:DESCRIPTION:Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476):LINK:https://www.cve.org/CVERecord?id=CVE-2020-6078::REFERENCE:CVE-2019-15900:DESCRIPTION:Chain: sscanf() call is used to check if a username and group exists, but the return value of sscanf() call is not checked (CWE-252), causing an uninitialized variable to be checked (CWE-457), returning success to allow authorization bypass for executing a privileged (CWE-863).:LINK:https://www.cve.org/CVERecord?id=CVE-2019-15900::REFERENCE:CVE-2007-3798:DESCRIPTION:Unchecked return value leads to resultant integer overflow and code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3798::REFERENCE:CVE-2006-4447:DESCRIPTION:Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4447::REFERENCE:CVE-2006-2916:DESCRIPTION:Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2916::REFERENCE:CVE-2008-5183:DESCRIPTION:chain: unchecked return value can lead to NULL dereference:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5183::REFERENCE:CVE-2010-0211:DESCRIPTION:chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0211::REFERENCE:CVE-2017-6964:DESCRIPTION:Linux-based device mapper encryption program does not check the return value of setuid and setgid allowing attackers to execute code with unintended privileges.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-6964::REFERENCE:CVE-2002-1372:DESCRIPTION:Chain: Return values of file/socket operations are not checked (CWE-252), allowing resultant consumption of file descriptors (CWE-772).:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1372::",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Unchecked Return Value::TAXONOMY NAME:CLASP:ENTRY NAME:Ignored function return value::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A7:ENTRY NAME:Improper Error Handling:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ERR33-C:ENTRY NAME:Detect and handle standard library errors:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:POS54-C:ENTRY NAME:Detect and handle POSIX library errors:MAPPING FIT:Imprecise::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:EXP00-J:ENTRY NAME:Do not ignore values returned by methods::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:EXP32-PL:ENTRY NAME:Do not ignore function return values:MAPPING FIT:Exact::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP4:ENTRY NAME:Unchecked Status Condition::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-252-resource::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-252-data::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-252-resource::",,"",
327,"Use of a Broken or Risky Cryptographic Algorithm",Class,Draft,"The product uses a broken or risky cryptographic algorithm or protocol.","Cryptographic algorithms are the methods by which data is scrambled to prevent observation or influence by unauthorized actors. Insecure cryptography can be exploited to expose sensitive information, modify data in unexpected ways, spoof identities of other users or devices, or other impacts. It is very difficult to produce a secure algorithm, and even high-profile algorithms by accomplished cryptographic experts have been broken. Well-known techniques exist to break or weaken various kinds of cryptography. Accordingly, there are a small number of well-understood and heavily studied algorithms that should be used by most products. Using a non-standard or known-insecure algorithm is dangerous because a determined adversary may be able to break the algorithm and compromise whatever data has been protected. Since the state of cryptography advances so rapidly, it is common for an algorithm to be considered unsafe even if it was once thought to be strong. This can happen when new attacks are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought. For a number of reasons, this weakness is even more challenging to manage with hardware deployment of cryptographic algorithms as opposed to software implementation. First, if a flaw is discovered with hardware-implemented cryptography, the flaw cannot be fixed in most cases without a recall of the product, because hardware is not easily replaceable like software. Second, because the hardware product is expected to work for years, the adversary's computing power will only increase over time.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:311:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation:NOTE:With hardware, the Architecture or Design Phase might start with compliant cryptography, but it is replaced with a non-compliant crypto during the later Implementation phase due to implementation constraints (e.g., not enough entropy to make it function properly, or not enough silicon real estate available to implement). Or, in rare cases (especially for long projects that span over years), the Architecture specifications might start with cryptography that was originally compliant at the time the Architectural specs were written, but over the time it became non-compliant due to progress made in attacking the crypto.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:The confidentiality of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:The integrity of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.::SCOPE:Accountability:SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:If the cryptographic algorithm is used to ensure the identity of the source of the data (such as digital signatures), then a broken algorithm will compromise this scheme and the source of the data cannot be proven.::","::METHOD:Automated Analysis:DESCRIPTION:Automated methods may be useful for recognizing commonly-used libraries or features that have become obsolete.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Binary / Bytecode simple extractor - strings, ELF readers, etc.:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Man-in-the-middle attack tool Cost effective for partial coverage: Framework-based Fuzzer Automated Monitored Execution Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis. For example, US government systems require FIPS 140-2 certification [REF-1192]. Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak. Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]::PHASE:Architecture and Design:DESCRIPTION:Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.:EFFECTIVENESS:Defense in Depth::PHASE:Architecture and Design:DESCRIPTION:Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.::PHASE:Implementation Architecture and Design:DESCRIPTION:When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.::","::REFERENCE:CVE-2022-30273:DESCRIPTION:SCADA-based protocol supports a legacy encryption mode that uses Tiny Encryption Algorithm (TEA) in ECB mode, which leaks patterns in messages and cannot protect integrity:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30273::REFERENCE:CVE-2022-30320:DESCRIPTION:Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30320::REFERENCE:CVE-2008-3775:DESCRIPTION:Product uses ROT-25 to obfuscate the password in the registry.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3775::REFERENCE:CVE-2007-4150:DESCRIPTION:product only uses XOR to obfuscate sensitive data:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4150::REFERENCE:CVE-2007-5460:DESCRIPTION:product only uses XOR and a fixed key to obfuscate sensitive data:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5460::REFERENCE:CVE-2005-4860:DESCRIPTION:Product substitutes characters with other characters in a fixed way, and also leaves certain input characters unchanged.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-4860::REFERENCE:CVE-2002-2058:DESCRIPTION:Attackers can infer private IP addresses by dividing each octet by the MD5 hash of '20'.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2058::REFERENCE:CVE-2008-3188:DESCRIPTION:Product uses DES when MD5 has been specified in the configuration, resulting in weaker-than-expected password hashes.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3188::REFERENCE:CVE-2005-2946:DESCRIPTION:Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2946::REFERENCE:CVE-2007-6013:DESCRIPTION:Product uses the hash of a hash for authentication, allowing attackers to gain privileges if they can obtain the original hash.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6013::",,,"::TAXONOMY NAME:CLASP:ENTRY NAME:Using a broken or risky cryptographic algorithm::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A8:ENTRY NAME:Insecure Storage:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC30-C:ENTRY NAME:Do not use the rand() function for generating pseudorandom numbers:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC32-C:ENTRY NAME:Properly seed pseudorandom number generators:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:MSC02-J:ENTRY NAME:Generate strong random numbers::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-327::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 4.3::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 4.3::",::20::459::473::475::608::614::97::,"::TYPE:Maintenance:NOTE:Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.::TYPE:Maintenance:NOTE:The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the Mapping CWE to 62443 subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.::",
396,"Declaration of Catch for Generic Exception",Base,Draft,"Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.","Multiple catch blocks can get ugly and repetitive, but condensing catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of a language's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.",::NATURE:ChildOf:CWE ID:705:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:755:VIEW ID:1000::NATURE:ChildOf:CWE ID:221:VIEW ID:1000::,"",::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C#:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Python:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Non-Repudiation:SCOPE:Other:IMPACT:Hide Activities:IMPACT:Alter Execution Logic::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Overly-Broad Catch Block::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP5:ENTRY NAME:Ambiguous Exception Type::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-396::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-396::",,"",
397,"Declaration of Throws for Generic Exception",Base,Draft,"Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.","Declaring a method to throw Exception or Throwable makes it difficult for callers to perform proper error handling and error recovery. Java's exception mechanism, for example, is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.",::NATURE:ChildOf:CWE ID:705:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:221:VIEW ID:1000::NATURE:ChildOf:CWE ID:703:VIEW ID:1000::,"",::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C#:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Non-Repudiation:SCOPE:Other:IMPACT:Hide Activities:IMPACT:Alter Execution Logic::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Overly-Broad Throws Declaration::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:ERR07-J:ENTRY NAME:Do not throw RuntimeException, Exception, or Throwable::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP5:ENTRY NAME:Ambiguous Exception Type::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-397::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-397::",,"::TYPE:Applicable Platform:NOTE:For C++, this weakness only applies to C++98, C++03, and C++11. It relies on a feature known as Dynamic Exception Specification, which was part of early versions of C++ but was deprecated in C++11. It has been removed for C++17 and later.::",
434,"Unrestricted Upload of File with Dangerous Type",Base,Draft,"The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.","",::NATURE:ChildOf:CWE ID:669:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:669:VIEW ID:1003:ORDINAL:Primary::NATURE:PeerOf:CWE ID:351:VIEW ID:1000::NATURE:PeerOf:CWE ID:436:VIEW ID:1000::NATURE:PeerOf:CWE ID:430:VIEW ID:1000::,"::ORDINALITY:Primary:DESCRIPTION:This can be primary when there is no check at all.::ORDINALITY:Resultant:DESCRIPTION:This is frequently resultant when use of double extensions (e.g. .php.gif) bypasses a sanity check.::ORDINALITY:Resultant:DESCRIPTION:This can be resultant from client-side enforcement (CWE-602); some products will include web script in web clients to check the filename, without verifying on the server side.::",::LANGUAGE NAME:ASP.NET:LANGUAGE PREVALENCE:Sometimes::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Web Server:TECHNOLOGY PREVALENCE:Sometimes::,"","::TERM:Unrestricted File Upload:DESCRIPTION:Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue.::","::PHASE:Implementation::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:Arbitrary code execution is possible if an uploaded file is interpreted and executed as code by the recipient. This is especially true for .asp and .php extensions uploaded to web servers because these file types are often treated as automatically executable, even when file system permissions do not specify execution. For example, in Unix environments, programs typically cannot run unless the execute bit is set, but PHP programs may be executed by the web server without directly invoking them on the operating system.::","::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Architecture and Design:DESCRIPTION:Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.::PHASE:Architecture and Design:DESCRIPTION:Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that filename.php.gif is fed to the PHP interpreter.[REF-422] [REF-423]::PHASE:Implementation:DESCRIPTION:When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:DESCRIPTION:Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.::PHASE:Implementation:DESCRIPTION:Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2023-5227:DESCRIPTION:PHP-based FAQ management app does not check the MIME type for uploaded images:LINK:https://www.cve.org/CVERecord?id=CVE-2023-5227::REFERENCE:CVE-2001-0901:DESCRIPTION:Web-based mail product stores .shtml attachments that could contain SSI:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0901::REFERENCE:CVE-2002-1841:DESCRIPTION:PHP upload does not restrict file types:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1841::REFERENCE:CVE-2005-1868:DESCRIPTION:upload and execution of .php file:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1868::REFERENCE:CVE-2005-1881:DESCRIPTION:upload file with dangerous extension:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1881::REFERENCE:CVE-2005-0254:DESCRIPTION:program does not restrict file types:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0254::REFERENCE:CVE-2004-2262:DESCRIPTION:improper type checking of uploaded files:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2262::REFERENCE:CVE-2006-4558:DESCRIPTION:Double php extension leaves an active php extension in the generated filename.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4558::REFERENCE:CVE-2006-6994:DESCRIPTION:ASP program allows upload of .asp files by bypassing client-side checks:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6994::REFERENCE:CVE-2005-3288:DESCRIPTION:ASP file upload:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3288::REFERENCE:CVE-2006-2428:DESCRIPTION:ASP file upload:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2428::",::File Processing::,::File or Directory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Unrestricted File Upload::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A3:ENTRY NAME:Malicious File Execution:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-434::",::1::,"::TYPE:Relationship:NOTE:This can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184). This can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.::",
456,"Missing Initialization of a Variable",Variant,Draft,"The product does not initialize critical variables, which causes the execution environment to use unexpected values.","",::NATURE:ChildOf:CWE ID:909:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:665:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:665:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:89:VIEW ID:1000::NATURE:CanPrecede:CWE ID:120:VIEW ID:1000::NATURE:CanPrecede:CWE ID:98:VIEW ID:1000::NATURE:CanPrecede:CWE ID:457:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Other:IMPACT:Unexpected State:IMPACT:Quality Degradation:IMPACT:Varies by Context:NOTE:The uninitialized data may be invalid, causing logic errors within the program. In some cases, this could result in a security problem.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Check that critical variables are initialized.::PHASE:Testing:DESCRIPTION:Use a static analysis tool to spot non-initialized variables.::","::REFERENCE:CVE-2020-6078:DESCRIPTION:Chain: The return value of a function returning a pointer is not checked for success (CWE-252) resulting in the later use of an uninitialized variable (CWE-456) and a null pointer dereference (CWE-476):LINK:https://www.cve.org/CVERecord?id=CVE-2020-6078::REFERENCE:CVE-2009-2692:DESCRIPTION:Chain: Use of an unimplemented network socket operation pointing to an uninitialized handler function (CWE-456) causes a crash because of a null pointer dereference (CWE-476).:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2692::REFERENCE:CVE-2020-20739:DESCRIPTION:A variable that has its value set in a conditional statement is sometimes used when the conditional fails, sometimes causing data leakage:LINK:https://www.cve.org/CVERecord?id=CVE-2020-20739::REFERENCE:CVE-2005-2978:DESCRIPTION:Product uses uninitialized variables for size and index, leading to resultant buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2978::REFERENCE:CVE-2005-2109:DESCRIPTION:Internal variable in PHP application is not initialized, allowing external modification.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2109::REFERENCE:CVE-2005-2193:DESCRIPTION:Array variable not initialized in PHP application, leading to resultant SQL injection.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2193::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Missing Initialization::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ERR30-C:ENTRY NAME:Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:DCL04-PL:ENTRY NAME:Always initialize local variables:MAPPING FIT:Exact::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:DCL33-PL:ENTRY NAME:Declare identifiers before using them:MAPPING FIT:Imprecise::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-456::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-456::",,"::TYPE:Relationship:NOTE:This weakness is a major factor in a number of resultant weaknesses, especially in web applications that allow global variable initialization (such as PHP) with libraries that can be directly requested.::TYPE:Research Gap:NOTE:It is highly likely that a large number of resultant weaknesses have missing initialization as a primary factor, but researcher reports generally do not provide this level of detail.::",
561,"Dead Code",Base,Draft,"The product contains dead code, which can never be executed.","Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.",::NATURE:ChildOf:CWE ID:1164:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Quality Degradation:NOTE:Dead code that results from code that can never be executed is an indication of problems with the source code that needs to be fixed and is an indication of poor quality.::SCOPE:Other:IMPACT:Reduce Maintainability::","::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode Quality Analysis Compare binary / bytecode to application permission manifest:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Automated Monitored Execution:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Permission Manifest Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source Code Quality Analyzer Cost effective for partial coverage: Warning Flags Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Remove dead code before deploying the application.::PHASE:Testing:DESCRIPTION:Use a static analysis tool to spot dead code.::","::REFERENCE:CVE-2014-1266:DESCRIPTION:chain: incorrect goto in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple goto fail bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).:LINK:https://www.cve.org/CVERecord?id=CVE-2014-1266::",,,"::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC07-C:ENTRY NAME:Detect and remove dead code::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:MSC00-PL:ENTRY NAME:Detect and remove dead code:MAPPING FIT:Exact::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP2:ENTRY NAME:Unused Entities::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-20::",,"",
606,"Unchecked Input for Loop Condition",Base,Draft,"The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service or other consequences because of excessive looping.","",::NATURE:ChildOf:CWE ID:1284:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:834:VIEW ID:1000::,"",,"","","::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU)::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Do not use user-controlled data for loop conditions.::PHASE:Implementation:DESCRIPTION:Perform input validation.::","",,,"::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP25:ENTRY NAME:Tainted input to variable::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-606::",,"",
667,"Improper Locking",Class,Draft,"The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.","Locking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.",::NATURE:ChildOf:CWE ID:662:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,"",,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):NOTE:Inconsistent locking discipline can lead to deadlock.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use industry standard APIs to implement locking mechanism.::","::REFERENCE:CVE-2021-1782:DESCRIPTION:Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-1782::REFERENCE:CVE-2009-0935:DESCRIPTION:Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0935::REFERENCE:CVE-2010-4210:DESCRIPTION:function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4210::REFERENCE:CVE-2008-4302:DESCRIPTION:Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4302::REFERENCE:CVE-2009-1243:DESCRIPTION:OS kernel performs an unlock in some incorrect circumstances, leading to panic.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1243::REFERENCE:CVE-2009-2857:DESCRIPTION:OS deadlock:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2857::REFERENCE:CVE-2009-1961:DESCRIPTION:OS deadlock involving 3 separate functions:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1961::REFERENCE:CVE-2009-2699:DESCRIPTION:deadlock in library:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2699::REFERENCE:CVE-2009-4272:DESCRIPTION:deadlock triggered by packets that force collisions in a routing table:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4272::REFERENCE:CVE-2002-1850:DESCRIPTION:read/write deadlock between web server and script:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1850::REFERENCE:CVE-2004-0174:DESCRIPTION:web server deadlock involving multiple listening connections:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0174::REFERENCE:CVE-2009-1388:DESCRIPTION:multiple simultaneous calls to the same function trigger deadlock.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1388::REFERENCE:CVE-2006-5158:DESCRIPTION:chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).:LINK:https://www.cve.org/CVERecord?id=CVE-2006-5158::REFERENCE:CVE-2006-4342:DESCRIPTION:deadlock when an operation is performed on a resource while it is being removed.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4342::REFERENCE:CVE-2006-2374:DESCRIPTION:Deadlock in device driver triggered by using file handle of a related device.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2374::REFERENCE:CVE-2006-2275:DESCRIPTION:Deadlock when large number of small messages cannot be processed quickly enough.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2275::REFERENCE:CVE-2005-3847:DESCRIPTION:OS kernel has deadlock triggered by a signal during a core dump.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3847::REFERENCE:CVE-2005-3106:DESCRIPTION:Race condition leads to deadlock.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3106::REFERENCE:CVE-2005-2456:DESCRIPTION:Chain: array index error (CWE-129) leads to deadlock (CWE-833):LINK:https://www.cve.org/CVERecord?id=CVE-2005-2456::REFERENCE:CVE-2001-0682:DESCRIPTION:Program can not execute when attacker obtains a mutex.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0682::REFERENCE:CVE-2002-1914:DESCRIPTION:Program can not execute when attacker obtains a lock on a critical output file.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1914::REFERENCE:CVE-2002-1915:DESCRIPTION:Program can not execute when attacker obtains a lock on a critical output file.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1915::REFERENCE:CVE-2002-0051:DESCRIPTION:Critical file can be opened with exclusive read access by user, preventing application of security policy. Possibly related to improper permissions, large-window race condition.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0051::REFERENCE:CVE-2000-0338:DESCRIPTION:Chain: predictable file names used for locking, allowing attacker to create the lock beforehand. Resultant from permissions and randomness.:LINK:https://www.cve.org/CVERecord?id=CVE-2000-0338::REFERENCE:CVE-2000-1198:DESCRIPTION:Chain: Lock files with predictable names. Resultant from randomness.:LINK:https://www.cve.org/CVERecord?id=CVE-2000-1198::REFERENCE:CVE-2002-1869:DESCRIPTION:Product does not check if it can write to a log file, allowing attackers to avoid logging by accessing the file using an exclusive lock. Overlaps unchecked error condition. This is not quite CWE-412, but close.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1869::",,,"::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:CON31-C:ENTRY NAME:Do not destroy a mutex while it is locked:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:POS48-C:ENTRY NAME:Do not unlock or destroy another POSIX thread's mutex:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:VNA00-J:ENTRY NAME:Ensure visibility when accessing shared primitive variables::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:VNA02-J:ENTRY NAME:Ensure that compound operations on shared variables are atomic::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:VNA05-J:ENTRY NAME:Ensure atomicity when reading and writing 64-bit values::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:LCK06-J:ENTRY NAME:Do not use an instance lock to protect shared static data::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP19:ENTRY NAME:Missing Lock::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-667::",::25::26::27::,"::TYPE:Maintenance:NOTE:Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.::",
672,"Operation on a Resource after Expiration or Release",Class,Draft,"The product uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.","",::NATURE:ChildOf:CWE ID:666:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:IMPACT:Modify Application Data:IMPACT:Read Application Data:NOTE:If a released resource is subsequently reused or reallocated, then an attempt to use the original resource might allow access to sensitive data that is associated with a different user or entity.::SCOPE:Other:SCOPE:Availability:IMPACT:Other:IMPACT:DoS: Crash, Exit, or Restart:NOTE:When a resource is released it might not be in an expected state, later attempts to access the resource may lead to resultant errors that may lead to a crash.::","","","::REFERENCE:CVE-2009-3547:DESCRIPTION:Chain: race condition (CWE-362) might allow resource to be released before operating on it, leading to NULL dereference (CWE-476):LINK:https://www.cve.org/CVERecord?id=CVE-2009-3547::",,,"::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP15:ENTRY NAME:Faulty Resource Use::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO46-C:ENTRY NAME:Do not access a closed file:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM30-C:ENTRY NAME:Do not access freed memory:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-672::",,"",
674,"Uncontrolled Recursion",Class,Draft,"The product does not properly control the amount of recursion that takes place, consuming excessive resources, such as allocated memory or the program stack.","",::NATURE:ChildOf:CWE ID:834:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Stack Exhaustion::","::PHASE:Implementation:NOTE:The uncontrolled recursion is often due to an improper or missing conditional::","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):NOTE:Resources including CPU, memory, and stack memory could be rapidly consumed or exhausted, eventually leading to an exit or crash.::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:In some cases, an application's interpreter might kill a process or thread that appears to be consuming too much resources, such as with PHP's memory_limit setting. When the interpreter kills the process/thread, it might report an error containing detailed information such as the application's installation path.::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Ensure an end condition will be reached under all logic conditions. The end condition may include testing against the depth of recursion and exiting with an error if the recursion goes too deep. The complexity of the end condition contributes to the effectiveness of this action.:EFFECTIVENESS:Moderate::PHASE:Implementation:DESCRIPTION:Increase the stack size.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2007-1285:DESCRIPTION:Deeply nested arrays trigger stack exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1285::REFERENCE:CVE-2007-3409:DESCRIPTION:Self-referencing pointers create infinite loop and resultant stack exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3409::REFERENCE:CVE-2016-10707:DESCRIPTION:Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.:LINK:https://www.cve.org/CVERecord?id=CVE-2016-10707::REFERENCE:CVE-2016-3627:DESCRIPTION:An attempt to recover a corrupted XML file infinite recursion protection counter was not always incremented missing the exit condition.:LINK:https://www.cve.org/CVERecord?id=CVE-2016-3627::REFERENCE:CVE-2019-15118:DESCRIPTION:USB-audio driver's descriptor code parsing allows unlimited recursion leading to stack exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-15118::",,::CPU::,"::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A9:ENTRY NAME:Denial of Service:MAPPING FIT:CWE More Specific::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP13:ENTRY NAME:Unrestricted Consumption::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-674::",::230::231::,"",
681,"Incorrect Conversion between Numeric Types",Base,Draft,"When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.","",::NATURE:ChildOf:CWE ID:704:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:704:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:682:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Other:SCOPE:Integrity:IMPACT:Unexpected State:IMPACT:Quality Degradation:NOTE:The program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability.::","","::PHASE:Implementation:DESCRIPTION:Avoid making conversion between numeric types. Always check for the allowed ranges.::","::REFERENCE:CVE-2022-2639:DESCRIPTION:Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787):LINK:https://www.cve.org/CVERecord?id=CVE-2022-2639::REFERENCE:CVE-2021-43537:DESCRIPTION:Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2021-43537::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::REFERENCE:CVE-2007-4988:DESCRIPTION:Chain: signed short width value in image processor is sign extended during conversion to unsigned int, which leads to integer overflow and heap-based buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4988::REFERENCE:CVE-2009-0231:DESCRIPTION:Integer truncation of length value leads to heap-based buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0231::REFERENCE:CVE-2008-3282:DESCRIPTION:Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3282::",,,"::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FLP34-C:ENTRY NAME:Ensure that floating point conversions are within range of the new type:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT15-C:ENTRY NAME:Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT31-C:ENTRY NAME:Ensure that integer conversions do not result in lost or misinterpreted data:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT35-C:ENTRY NAME:Evaluate integer expressions in a larger size before comparing or assigning to that size::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:NUM12-J:ENTRY NAME:Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-681::",,"",
704,"Incorrect Type Conversion or Cast",Class,Incomplete,"The product does not correctly convert an object, resource, or structure from one type to a different type.","",::NATURE:ChildOf:CWE ID:664:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Other::","::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.:EFFECTIVENESS:High::","","::REFERENCE:CVE-2021-43537:DESCRIPTION:Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2021-43537::REFERENCE:CVE-2022-3979:DESCRIPTION:Chain: data visualization program written in PHP uses the != operator instead of the type-strict !== operator (CWE-480) when validating hash values, potentially leading to an incorrect type conversion (CWE-704):LINK:https://www.cve.org/CVERecord?id=CVE-2022-3979::",,,"::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP05-C:ENTRY NAME:Do not cast away a const qualification::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP39-C:ENTRY NAME:Do not access a variable through a pointer of an incompatible type:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT31-C:ENTRY NAME:Ensure that integer conversions do not result in lost or misinterpreted data:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT36-C:ENTRY NAME:Converting a pointer to integer or integer to pointer:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR34-C:ENTRY NAME:Cast characters to unsigned types before converting to larger integer sizes:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR37-C:ENTRY NAME:Arguments to character handling functions must be representable as an unsigned char:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-704::",,"",
766,"Critical Data Element Declared Public",Base,Incomplete,"The product declares a critical variable, field, or member to be public when intended security policy requires it to be private.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:732:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000::,"::ORDINALITY:Primary::ORDINALITY:Indirect::",::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C#:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:IMPACT:Read Application Data:IMPACT:Modify Application Data:NOTE:Making a critical variable public allows anyone with access to the object in which the variable is contained to alter or read the value.::SCOPE:Other:IMPACT:Reduce Maintainability::","::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation:DESCRIPTION:Data should be private, static, and final whenever possible. This will assure that your code is protected by instantiating early, preventing access, and preventing tampering.::","::REFERENCE:CVE-2010-3860:DESCRIPTION:variables declared public allow remote read of system properties such as user name and home directory.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3860::",,,"::TAXONOMY NAME:CLASP:ENTRY NAME:Failure to protect stored data from modification::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:OBJ01-J:ENTRY NAME:Declare data members as private and provide accessible wrapper methods::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP28:ENTRY NAME:Unexpected access points::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-15::",,"",
772,"Missing Release of Resource after Effective Lifetime",Base,Draft,"The product does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.","When a resource is not released after use, it can allow attackers to cause a denial of service by causing the allocation of resources without triggering their release. Frequently-affected resources include memory, CPU, disk space, power or battery, etc.",::NATURE:ChildOf:CWE ID:404:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1340:ORDINAL:Primary::,"",::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:An attacker that can influence the allocation of resources that are not properly released could deplete the available resource pool and prevent all other processes from accessing the same type of resource.::","","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.::PHASE:Implementation:DESCRIPTION:It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free resources in a function. If you allocate resources that you intend to free upon completion of the function, you must be sure to free the resources at all exit points for that function including error conditions.::PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:DESCRIPTION:Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).::","::REFERENCE:CVE-2007-0897:DESCRIPTION:Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0897::REFERENCE:CVE-2001-0830:DESCRIPTION:Sockets not properly closed when attacker repeatedly connects and disconnects from server.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0830::REFERENCE:CVE-1999-1127:DESCRIPTION:Does not shut down named pipe connections if malformed data is sent.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-1127::REFERENCE:CVE-2009-2858:DESCRIPTION:Chain: memory leak (CWE-404) leads to resource exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2858::REFERENCE:CVE-2009-2054:DESCRIPTION:Product allows exhaustion of file descriptors when processing a large number of TCP packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2054::REFERENCE:CVE-2008-2122:DESCRIPTION:Port scan triggers CPU consumption with processes that attempt to read data from closed sockets.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2122::REFERENCE:CVE-2007-4103:DESCRIPTION:Product allows resource exhaustion via a large number of calls that do not complete a 3-way handshake.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4103::REFERENCE:CVE-2002-1372:DESCRIPTION:Chain: Return values of file/socket operations are not checked (CWE-252), allowing resultant consumption of file descriptors (CWE-772).:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1372::",,,"::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO42-C:ENTRY NAME:Close files when they are no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM31-C:ENTRY NAME:Free dynamically allocated memory when no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-772::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-772::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP14:ENTRY NAME:Failure to Release Resource::",::469::,"::TYPE:Maintenance:NOTE:Resource exhaustion (CWE-400) is currently treated as a weakness, although it is more like a category of weaknesses that all have the same type of consequence. While this entry treats CWE-400 as a parent in view 1000, the relationship is probably more appropriately described as a chain.::TYPE:Theoretical:NOTE:Vulnerability theory is largely about how behaviors and resources interact. Resource exhaustion can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.::",
788,"Access of Memory Location After End of Buffer",Base,Incomplete,"The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.","This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,"",,"","","","",,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.::SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.::","::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","","::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0689::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0558::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4113::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-788::",,"",
789,"Memory Allocation with Excessive Size Value",Variant,Draft,"The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.","",::NATURE:ChildOf:CWE ID:770:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:476:VIEW ID:1000::,"::ORDINALITY:Primary::ORDINALITY:Resultant::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Stack Exhaustion:DESCRIPTION:When a weakness allocates excessive memory on the stack, it is often described as stack exhaustion, which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.::","::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Memory):NOTE:Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system.::","::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::","::PHASE:Implementation Architecture and Design:DESCRIPTION:Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.::PHASE:Operation:DESCRIPTION:Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.::","::REFERENCE:CVE-2022-21668:DESCRIPTION:Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).:LINK:https://www.cve.org/CVERecord?id=CVE-2022-21668::REFERENCE:CVE-2010-3701:DESCRIPTION:program uses ::alloca() for encoding messages, but large messages trigger segfault:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3701::REFERENCE:CVE-2008-1708:DESCRIPTION:memory consumption and daemon exit by specifying a large value in a length field:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1708::REFERENCE:CVE-2008-0977:DESCRIPTION:large value in a length field leads to memory consumption and crash when no more memory is available:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0977::REFERENCE:CVE-2006-3791:DESCRIPTION:large key size in game program triggers crash when a resizing function cannot allocate enough memory:LINK:https://www.cve.org/CVERecord?id=CVE-2006-3791::REFERENCE:CVE-2004-2589:DESCRIPTION:large Content-Length HTTP header value triggers application crash in instant messaging application due to failure in memory allocation:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2589::",,,"::TAXONOMY NAME:WASC:ENTRY ID:35:ENTRY NAME:SOAP Array Abuse::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM35-C:ENTRY NAME:Allocate sufficient memory for an object:MAPPING FIT:Imprecise::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS32-PL:ENTRY NAME:Validate any integer that is used as an array index:MAPPING FIT:Imprecise::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-789::",,"::TYPE:Relationship:NOTE:This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.::TYPE:Applicable Platform:NOTE:Uncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.::",
798,"Use of Hard-coded Credentials",Base,Draft,"The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.","Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.",::NATURE:ChildOf:CWE ID:1391:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:287:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:344:VIEW ID:1000::NATURE:ChildOf:CWE ID:671:VIEW ID:1000::NATURE:PeerOf:CWE ID:257:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::,"","","::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Read Application Data:IMPACT:Gain Privileges or Assume Identity:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Other:NOTE:This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.::","::METHOD:Black Box:DESCRIPTION:Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.:EFFECTIVENESS:Moderate::METHOD:Automated Static Analysis:DESCRIPTION:Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods.::METHOD:Manual Static Analysis:DESCRIPTION:This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.::METHOD:Manual Dynamic Analysis:DESCRIPTION:For hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Network Sniffer Forced Path Execution:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction:EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7]. In Windows environments, the Encrypted File System (EFS) may provide some protection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a first login mode that requires the user to enter a unique strong password or key.::PHASE:Architecture and Design:DESCRIPTION:If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash. Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.::PHASE:Architecture and Design:DESCRIPTION:For front-end to back-end connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.::","::REFERENCE:CVE-2022-29953:DESCRIPTION:Condition Monitor firmware has a maintenance interface with hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29953::REFERENCE:CVE-2022-29960:DESCRIPTION:Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29960::REFERENCE:CVE-2022-29964:DESCRIPTION:Distributed Control System (DCS) has hard-coded passwords for local shell access:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29964::REFERENCE:CVE-2022-30997:DESCRIPTION:Programmable Logic Controller (PLC) has a maintenance service that uses undocumented, hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30997::REFERENCE:CVE-2022-30314:DESCRIPTION:Firmware for a Safety Instrumented System (SIS) has hard-coded credentials for access to boot configuration:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30314::REFERENCE:CVE-2022-30271:DESCRIPTION:Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used in typical deployments:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30271::REFERENCE:CVE-2021-37555:DESCRIPTION:Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]:LINK:https://www.cve.org/CVERecord?id=CVE-2021-37555::REFERENCE:CVE-2021-35033:DESCRIPTION:Firmware for a WiFi router uses a hard-coded password for a BusyBox shell, allowing bypass of authentication through the UART port:LINK:https://www.cve.org/CVERecord?id=CVE-2021-35033::REFERENCE:CVE-2012-3503:DESCRIPTION:Installation script has a hard-coded secret token value, allowing attackers to bypass authentication:LINK:https://www.cve.org/CVERecord?id=CVE-2012-3503::REFERENCE:CVE-2010-2772:DESCRIPTION:SCADA system uses a hard-coded password to protect back-end database containing authorization information, exploited by Stuxnet worm:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2772::REFERENCE:CVE-2010-2073:DESCRIPTION:FTP server library uses hard-coded usernames and passwords for three default accounts:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2073::REFERENCE:CVE-2010-1573:DESCRIPTION:Chain: Router firmware uses hard-coded username and password for access to debug functionality, which can be used to execute arbitrary code:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1573::REFERENCE:CVE-2008-2369:DESCRIPTION:Server uses hard-coded authentication key:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2369::REFERENCE:CVE-2008-0961:DESCRIPTION:Backup product uses hard-coded username and password, allowing attackers to bypass authentication via the RPC interface:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0961::REFERENCE:CVE-2008-1160:DESCRIPTION:Security appliance uses hard-coded password allowing attackers to gain root access:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1160::REFERENCE:CVE-2006-7142:DESCRIPTION:Drive encryption product stores hard-coded cryptographic keys for encrypted configuration files in executable programs:LINK:https://www.cve.org/CVERecord?id=CVE-2006-7142::REFERENCE:CVE-2005-3716:DESCRIPTION:VoIP product uses hard-coded public credentials that cannot be changed, which allows attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3716::REFERENCE:CVE-2005-3803:DESCRIPTION:VoIP product uses hard coded public and private SNMP community strings that cannot be changed, which allows remote attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3803::REFERENCE:CVE-2005-0496:DESCRIPTION:Backup product contains hard-coded credentials that effectively serve as a back door, which allows remote attackers to access the file system:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0496::",,,"::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:MSC03-J:ENTRY NAME:Never hard code sensitive information::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-798::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 1.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 1.5::",::191::70::,"::TYPE:Maintenance:NOTE:The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the Mapping CWE to 62443 subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.::",
835,"Loop with Unreachable Exit Condition ('Infinite Loop')",Base,Incomplete,"The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.","If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.",::NATURE:ChildOf:CWE ID:834:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:834:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","","",,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):IMPACT:DoS: Amplification:NOTE:An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory. The software's operation may slow down, or cause a long time to respond.::","","","::REFERENCE:CVE-2022-22224:DESCRIPTION:Chain: an operating system does not properly process malformed Open Shortest Path First (OSPF) Type/Length/Value Identifiers (TLV) (CWE-703), which can cause the process to enter an infinite loop (CWE-835):LINK:https://www.cve.org/CVERecord?id=CVE-2022-22224::REFERENCE:CVE-2022-25304:DESCRIPTION:A Python machine communication platform did not account for receiving a malformed packet with a null size, causing the receiving function to never update the message buffer and be caught in an infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-25304::REFERENCE:CVE-2011-1027:DESCRIPTION:Chain: off-by-one error (CWE-193) leads to infinite loop (CWE-835) using invalid hex-encoded characters.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1027::REFERENCE:CVE-2011-1142:DESCRIPTION:Chain: self-referential values in recursive definitions lead to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1142::REFERENCE:CVE-2011-1002:DESCRIPTION:NULL UDP packet is never cleared from a queue, leading to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1002::REFERENCE:CVE-2006-6499:DESCRIPTION:Chain: web browser crashes due to infinite loop - bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6499::REFERENCE:CVE-2010-4476:DESCRIPTION:Floating point conversion routine cycles back and forth between two different values.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4476::REFERENCE:CVE-2010-4645:DESCRIPTION:Floating point conversion routine cycles back and forth between two different values.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4645::REFERENCE:CVE-2010-2534:DESCRIPTION:Chain: improperly clearing a pointer in a linked list leads to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2534::REFERENCE:CVE-2013-1591:DESCRIPTION:Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.:LINK:https://www.cve.org/CVERecord?id=CVE-2013-1591::REFERENCE:CVE-2008-3688:DESCRIPTION:Chain: A denial of service may be caused by an uninitialized variable (CWE-457) allowing an infinite loop (CWE-835) resulting from a connection to an unresponsive server.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3688::",,,"::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-835::",,"",
1041,"Use of Redundant Code",Base,Incomplete,"The product has multiple functions, methods, procedures, macros, etc. that contain the same code.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. For example, if there are two copies of the same code, the programmer might fix a weakness in one copy while forgetting to fix the same weakness in another copy.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","::PHASE:Implementation:DESCRIPTION:Merge common functionality into a single function and then call that function from across the entire code base.::","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-19::",,"",
1042,"Static Member Data Element outside of a Singleton Class Element",Variant,Incomplete,"The code contains a member element that is declared as static (but not final), in which its parent class element is not a singleton class - that is, a class element that can be used only once in the 'to' association of a Create action.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1176:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-3::",,"",
1043,"Data Element Aggregating an Excessively Large Number of Non-Primitive Elements",Base,Incomplete,"The product uses a data element that has an excessively large number of sub-elements with non-primitive data types such as structures or aggregated objects.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of excessively large may vary for each product or developer, CISQ recommends a default of 5 sub-elements.",::NATURE:ChildOf:CWE ID:1093:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-12::",,"",
1044,"Architecture with Number of Horizontal Layers Outside of Expected Range",Base,Incomplete,"The product's architecture contains too many - or too few - horizontal layers.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of expected range may vary for each product or developer, CISQ recommends a default minimum of 4 layers and maximum of 8 layers.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","::PHASE:Architecture and Design::","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-9::",,"",
1045,"Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor",Base,Incomplete,"A parent class has a virtual destructor method, but the parent has a child class that does not have a virtual destructor.","This issue can prevent the product from running reliably, since the child might not perform essential destruction operations. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability, such as a memory leak (CWE-401).",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-17::",,"",
1046,"Creation of Immutable Text Using String Concatenation",Base,Incomplete,"The product creates an immutable text string using string concatenation operations.","When building a string via a looping feature (e.g., a FOR or WHILE loop), the use of += to append to the existing string will result in the creation of a new object with each iteration. This programming pattern can be inefficient in comparison with use of text buffer data elements. This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this could be influenced to create performance problem.",::NATURE:ChildOf:CWE ID:1176:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-2::",,"",
1047,"Modules with Circular Dependencies",Base,Incomplete,"The product contains modules in which one module has references that cycle back to itself, i.e., there are circular dependencies.","As an example, with Java, this weakness might indicate cycles between packages. This issue makes it more difficult to maintain the product due to insufficient modularity, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-7::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-13::",,"",
1048,"Invokable Control Element with Large Number of Outward Calls",Base,Incomplete,"The code contains callable control elements that contain an excessively large number of references to other application objects external to the context of the callable, i.e. a Fan-Out value that is excessively large.","While the interpretation of excessively large Fan-Out value may vary for each product or developer, CISQ recommends a default of 5 referenced objects. This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-4::",,"",
1049,"Excessive Data Query Operations in a Large Data Table",Base,Incomplete,"The product performs a data query with a large number of joins and sub-queries on a large data table.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and large number of joins or sub-queries may vary for each product or developer, CISQ recommends a default of 1 million rows for a large data table, a default minimum of 5 joins, and a default minimum of 3 sub-queries.",::NATURE:ChildOf:CWE ID:1176:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-4::",,"",
1050,"Excessive Platform Resource Consumption within a Loop",Base,Incomplete,"The product has a loop body or loop condition that contains a control element that directly or indirectly consumes platform resources, e.g. messaging, sessions, locks, or file descriptors.","This issue can make the product perform more slowly. If an attacker can influence the number of iterations in the loop, then this performance problem might allow a denial of service by consuming more platform resources than intended.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-8::",,"",
1051,"Initialization with Hard-Coded Network Resource Configuration Data",Base,Incomplete,"The product initializes data using hard-coded values that act as network resource identifiers.","This issue can prevent the product from running reliably, e.g. if it runs in an environment does not use the hard-coded network resource identifiers. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1419:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-18::",,"",
1052,"Excessive Use of Hard-Coded Literals in Initialization",Base,Incomplete,"The product initializes a data element using a hard-coded literal that is not a simple integer or static constant element.","This issue makes it more difficult to modify or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1419:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-3::",,"",
1054,"Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer",Base,Incomplete,"The code at one architectural layer invokes code that resides at a deeper layer than the adjacent layer, i.e., the invocation skips at least one layer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer.","This issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-12::",,"",
1055,"Multiple Inheritance from Concrete Classes",Base,Incomplete,"The product contains a class with inheritance from more than one concrete class.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1093:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-2::",,"",
1056,"Invokable Control Element with Variadic Parameters",Base,Incomplete,"A named-callable or method control element has a signature that supports a variable (variadic) number of parameters or arguments.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. With variadic arguments, it can be difficult or inefficient for manual analysis to be certain of which function/method is being invoked.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-8::",,"",
1057,"Data Access Operations Outside of Expected Data Manager Component",Base,Incomplete,"The product uses a dedicated, central data manager component as required by design, but it contains code that performs data-access operations that do not use this data manager.","This issue can make the product perform more slowly than intended, since the intended central data manager may have been explicitly optimized for performance or other quality characteristics. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-11::",,"",
1058,"Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element",Base,Incomplete,"The code contains a function or method that operates in a multi-threaded environment but owns an unsafe non-final static storable or member data element.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:662:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-11::",,"",
1060,"Excessive Number of Inefficient Server-Side Data Accesses",Base,Incomplete,"The product performs too many data queries without using efficient data processing functionality such as stored procedures.","This issue can make the product perform more slowly due to computational expense. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of too many data queries may vary for each product or developer, CISQ recommends a default maximum of 5 data queries for an inefficient function/procedure.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-9::",,"",
1062,"Parent Class with References to Child Class",Base,Incomplete,"The code has a parent class that contains references to a child class, its methods, or its members.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-14::",,"",
1063,"Creation of Class Instance within a Static Code Block",Base,Incomplete,"A static code block creates an instance of a class.","This pattern identifies situations where a storable data element or member data element is initialized with a value in a block of code which is declared as static. This issue can make the product perform more slowly by performing initialization before it is needed. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1176:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-1::",,"",
1064,"Invokable Control Element with Signature Containing an Excessive Number of Parameters",Base,Incomplete,"The product contains a function, subroutine, or method whose signature has an unnecessarily large number of parameters/arguments.","This issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of parameters. may vary for each product or developer, CISQ recommends a default maximum of 7 parameters/arguments.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-13::",,"",
1065,"Runtime Resource Management Control Element in a Component Built to Run on Application Servers",Base,Incomplete,"The product uses deployed components from application servers, but it also uses low-level functions/methods for management of resources, instead of the API provided by the application server.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-5::",,"",
1066,"Missing Serialization Control Element",Base,Incomplete,"The product contains a serializable data element that does not have an associated serialization method.","This issue can prevent the product from running reliably, e.g. by triggering an exception. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. As examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-2::",,"",
1067,"Excessive Execution of Sequential Searches of Data Resource",Base,Incomplete,"The product contains a data query against an SQL table or view that is configured in a way that does not utilize an index and may cause sequential searches to be performed.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1176:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-5::",,"",
1069,"Empty Exception Block",Variant,Incomplete,"An invokable code block contains an exception handling block that does not contain any code, i.e. is empty.","When an exception handling block (such as a Catch and Finally block) is used, but that block is empty, this can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1071:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","::PHASE:Implementation:DESCRIPTION:For every exception block add code that handles the specific exception in the way intended by the application.::","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-1::",,"",
1070,"Serializable Data Element Containing non-Serializable Item Elements",Base,Incomplete,"The product contains a serializable, storable data element such as a field or member, but the data element contains member elements that are not serializable.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability. As examples, the serializable nature of a data element comes from a serializable SerializableAttribute attribute in .NET and the inheritance from the java.io.Serializable interface in Java.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-3::",,"",
1072,"Data Resource Access without Use of Connection Pooling",Base,Incomplete,"The product accesses a data resource through a database without using a connection pooling capability.","This issue can make the product perform more slowly, as connection pools allow connections to be reused without the overhead and time consumption of opening and closing a new connection. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-13::",,"",
1073,"Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses",Base,Incomplete,"The product contains a client with a function or method that contains a large number of data accesses/queries that are sent through a data manager, i.e., does not use efficient database capabilities.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large number of data accesses/queries may vary for each product or developer, CISQ recommends a default maximum of 2 data accesses per function/method.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-10::",,"",
1074,"Class with Excessively Deep Inheritance",Base,Incomplete,"A class has an inheritance level that is too high, i.e., it has a large number of parent classes.","This issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of parent classes may vary for each product or developer, CISQ recommends a default maximum of 7 parent classes.",::NATURE:ChildOf:CWE ID:1093:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-17::",,"",
1075,"Unconditional Control Flow Transfer outside of Switch Block",Base,Incomplete,"The product performs unconditional control transfer (such as a goto) in code outside of a branching structure such as a switch block.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-1::",,"",
1077,"Floating Point Comparison with Incorrect Operator",Variant,Incomplete,"The code performs a comparison such as an equality test between two float (floating point) values, but it uses comparison operators that do not account for the possibility of loss of precision.","Numeric calculation using floating point values can generate imprecise results because of rounding errors. As a result, two different calculations might generate numbers that are mathematically equal, but have slightly different bit representations that do not translate to the same mathematically-equal values. As a result, an equality test or other comparison might produce unexpected results. This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:697:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-9::",,"",
1079,"Parent Class without Virtual Destructor Method",Base,Incomplete,"A parent class contains one or more child classes, but the parent class does not have a virtual destructor method.","This issue can prevent the product from running reliably due to undefined or unexpected behaviors. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-16::",,"",
1080,"Source Code File with Excessive Number of Lines of Code",Base,Incomplete,"A source code file has too many lines of code.","This issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of too many lines of code may vary for each product or developer, CISQ recommends a default threshold value of 1000.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-8::",,"",
1082,"Class Instance Self Destruction Control Element",Base,Incomplete,"The code contains a class instance that calls the method or function to delete or destroy itself.","For example, in C++, delete this will cause the object to delete itself. This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-7::",,"",
1083,"Data Access from Outside Expected Data Manager Component",Base,Incomplete,"The product is intended to manage data access through a particular data manager component such as a relational or non-SQL database, but it contains code that performs data access operations without using that component.","When the product has a data access component, the design may be intended to handle all data access operations through that component. If a data access operation is performed outside of that component, then this may indicate a violation of the intended design. This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-10::",,"",
1084,"Invokable Control Element with Excessive File or Data Access Operations",Base,Incomplete,"A function or method contains too many operations that utilize a data manager or file resource.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of too many operations may vary for each product or developer, CISQ recommends a default maximum of 7 operations for the same data manager or file.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-14::",,"",
1085,"Invokable Control Element with Excessive Volume of Commented-out Code",Base,Incomplete,"A function, method, procedure, etc. contains an excessive amount of code that has been commented out within its body.","This issue makes it more difficult to maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of excessive volume may vary for each product or developer, CISQ recommends a default threshold of 2% of commented code.",::NATURE:ChildOf:CWE ID:1078:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-6::",,"",
1086,"Class with Excessive Number of Child Classes",Base,Incomplete,"A class contains an unnecessarily large number of children.","This issue makes it more difficult to understand and maintain the software, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities. While the interpretation of large number of children may vary for each product or developer, CISQ recommends a default maximum of 10 child classes.",::NATURE:ChildOf:CWE ID:1093:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-18::",,"",
1087,"Class with Virtual Method without a Virtual Destructor",Base,Incomplete,"A class contains a virtual method, but the method does not have an associated virtual destructor.","This issue can prevent the product from running reliably, e.g. due to undefined behavior. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-15::",,"",
1088,"Synchronous Access of Remote Resource without Timeout",Base,Incomplete,"The code has a synchronous call to a remote resource, but there is no timeout for the call, or the timeout is set to infinite.","This issue can prevent the product from running reliably, since an outage for the remote resource can cause the product to hang. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:821:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-19::",,"",
1089,"Large Data Table with Excessive Number of Indices",Base,Incomplete,"The product uses a large data table that contains an excessively large number of indices.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and excessively large number of indices may vary for each product or developer, CISQ recommends a default threshold of 1000000 rows for a large table and a default threshold of 3 indices.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-6::",,"",
1090,"Method Containing Access of a Member Element from Another Class",Base,Incomplete,"A method for a class performs an operation that directly accesses a member element from another class.","This issue suggests poor encapsulation and makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1061:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-16::",,"",
1091,"Use of Object without Invoking Destructor Method",Base,Incomplete,"The product contains a method that accesses an object but does not later invoke the element's associated finalize/destructor method.","This issue can make the product perform more slowly by retaining memory and/or other resources longer than necessary. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:772:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-15::",,"",
1092,"Use of Same Invokable Control Element in Multiple Architectural Layers",Base,Incomplete,"The product uses the same control element across multiple architectural layers.","This issue makes it more difficult to understand and maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-10::",,"",
1094,"Excessive Index Range Scan for a Data Resource",Base,Incomplete,"The product contains an index range scan for a large data table, but the scan can cover a large number of rows.","This issue can make the product perform more slowly. If the relevant code is reachable by an attacker, then this performance problem might introduce a vulnerability. While the interpretation of large data table and excessive index range may vary for each product or developer, CISQ recommends a threshold of 1000000 table rows and a threshold of 10 for the index range.",::NATURE:ChildOf:CWE ID:405:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Performance::","","","",,,"::TAXONOMY NAME:OMG ASCPEM:ENTRY ID:ASCPEM-PRF-7::",,"",
1095,"Loop Condition Value Update within the Loop",Base,Incomplete,"The product uses a loop with a control flow condition based on a value that is updated within the body of the loop.","This issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Maintainability::","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-5::",,"",
1096,"Singleton Class Instance Creation without Proper Locking or Synchronization",Variant,Incomplete,"The product implements a Singleton design pattern but does not use appropriate locking or other synchronization mechanism to ensure that the singleton class is only instantiated once.","This issue can prevent the product from running reliably, e.g. by making the instantiation process non-thread-safe and introducing deadlock (CWE-833) or livelock conditions. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:820:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-12::",,"",
1097,"Persistent Storable Data Element without Associated Comparison Control Element",Base,Incomplete,"The product uses a storable data element that does not have all of the associated functions or methods that are necessary to support comparison.","For example, with Java, a class that is made persistent requires both hashCode() and equals() methods to be defined. This issue can prevent the product from running reliably, due to incorrect or unexpected comparison results. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:595:VIEW ID:1305:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-4::",,"",
1098,"Data Element containing Pointer Item without Proper Copy Control Element",Base,Incomplete,"The code contains a data element with a pointer that does not have an associated copy or constructor method.","This issue can prevent the product from running reliably. If the relevant code is reachable by an attacker, then this reliability problem might introduce a vulnerability.",::NATURE:ChildOf:CWE ID:1076:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"::SCOPE:Other:IMPACT:Reduce Reliability::","","","",,,"::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-RLB-6::",,"",
1121,"Excessive McCabe Cyclomatic Complexity",Base,Incomplete,"The code contains McCabe cyclomatic complexity that exceeds a desirable maximum.","This issue makes it more difficult to understand and/or maintain the product, which indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. It also might make it easier to introduce vulnerabilities.",::NATURE:ChildOf:CWE ID:1120:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"","","","",,,"::TAXONOMY NAME:OMG ASCMM:ENTRY ID:ASCMM-MNT-11::",,"",
